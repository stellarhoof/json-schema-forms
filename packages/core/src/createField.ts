import _ from "lodash/fp.js"
import { get, set } from "lodash"
import { Required } from "utility-types"
import { Collection, Tree } from "@json-schema-form/tree-utils"
import {
  JsonSchema,
  getSchemaValue,
  getChildrenSchemasFromValue,
} from "json-schema-utils"
import { formTree } from "./util.js"
import { FieldId, FormConfig } from "./createForm.js"

export type Field<P extends object = object> = P & {
  /**
   * Field id
   */
  id: FieldId

  /**
   * Property name in an object schema or index in an array schema
   */
  key?: string | number

  /**
   * Schema this field belongs to
   */
  readonly schema: JsonSchema

  /**
   * Field keys starting from the root field
   *
   * Root node has empty path
   */
  readonly path: (string | number)[]

  /**
   * Parent field
   */
  readonly parent: Field<P> | undefined

  /**
   * Children fields
   */
  children: Collection<Field<P>> | undefined

  /**
   * This field's value
   */
  value: any

  /**
   * This field's initial value
   */
  initial: any

  /**
   * Mark all fields as clean (not dirty)
   */
  clean: () => void

  /**
   * Reset field value to its initial value
   */
  reset: () => void

  /**
   * Whether this field's value has changed from its initial value
   */
  dirty: boolean

  /**
   * If set, this field will not participate in validation (`willValidate` will be `false`).
   *
   * The `disabled` state is inherited by all fields nested under this one.
   * The `disabled` state should "stack", e.g. if two parents are
   * `disabled`, only by clearing them both can this field be enabled again
   * (assumming this field itself is not `disabled`).
   *
   * Also, the UI control displaying this field should ensure `disabled` is set
   * on the underlying control element to prevent it from being submitted.
   *
   * @see {@link "https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/disabled"}
   */
  disabled: boolean

  /**
   * Equivalent to the {@link "https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/hidden" hidden} HTML attribute on an input element. Setting `hidden` excludes this field from validation.
   */
  hidden: boolean

  /**
   * `true` if the parent schema has `type: object` and its `required` property includes this field's `name`
   *
   * @remarks
   *
   * Setting this property toggles this field's `name` in `parent.schema.required`
   */
  required: boolean

  /**
   * @see {@link "https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#dom-cva-willvalidate"}
   */
  readonly willValidate: boolean

  /**
   * @see {@link "https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#dom-cva-setcustomvalidity"}
   */
  setCustomValidity: (message: string) => void

  /**
   * @see {@link "https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#dom-cva-checkvalidity"}
   */
  checkValidity: () => boolean

  /**
   * @see {@link "https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#dom-cva-validationmessage"}
   */
  readonly validationMessage: string

  /**
   * A simple check against the `schema.maxItems` json-schema keyword
   *
   * @see {@link "https://json-schema.org/draft/2020-12/json-schema-validation.html#name-maxitems"}
   */
  readonly canAddChild: boolean

  /**
   * A simple check against the `schema.minItems` json-schema keyword
   *
   * @see {@link "https://json-schema.org/draft/2020-12/json-schema-validation.html#name-minitems"}
   */
  readonly canRemoveChild: boolean

  /**
   * Insert a new item at `index` to `items` and `value` arrays
   *
   * @remarks
   *
   * The new item will be cloned from `schema.items` and initialized just as a top-level form schema would (e.g. `field`s will be recursively added). An new, empty value will be generated by `getSchemaValue(schema.items)` and inserted into `value`.
   *
   * @param index - The index at which to insert the new item. Defaults to `value.length` if omitted.
   */
  addChild: (index?: number) => void

  /**
   * Remove an item at `index` from `items` and `value` arrays
   *
   * @param index - The index at which to remove the element. Defaults to `value.length` if omitted.
   */
  removeChild: (index?: number) => void

  dispose: () => void

  /** Internal. Do not use. */
  readonly __state__: any
}

export interface FormContext<P extends object> {
  /**
   * A map of FieldId -> ResultField that holds all the fields in the form.
   *
   * This is necessary because a field contains references to other fields
   * (including itself) and `mapField` may return new fields, making such
   * references stale.
   *
   * The following snippet illustrates the problem:
   *
   * ```javascript
   * const createField = (parent) => {
   *   const field = {
   *     get self() { return field },
   *     get parent() { return parent },
   *   }
   *   return field
   * }
   *
   * const parent = mapField(createField()) // `parent.self` is stale now
   * const field = mapField(createField(parent)) // `field.self` is stale now
   * ```
   *
   * Now a snippet that illustrates how `fieldMap` solves the problem:
   *
   * ```javascript
   * const fieldMap = new Map()
   *
   * const createField = (parentId, selfId) => ({
   *   get self() { return fieldMap.get(selfId) },
   *   get parent() { return fieldMap.get(parentId) },
   * })
   *
   * const parentId = Symbol()
   * fieldMap.set(parentId, mapField(createField(null, parentId)))
   *
   * const selfId = Symbol()
   * fieldMap.set(selfId, mapField(createField(parentId, selfId)))
   * ```
   */
  fieldMap: Map<FieldId, Field<P>>
  createStore: <T>(value: T) => T
  value: { initial: any; current: any }
  onCreateField: Required<FormConfig<P>>["onCreateField"]
}

interface CreateFieldProps<P extends object> {
  id: FieldId
  parentId?: FieldId
  key?: string | number
  jsonSchema: JsonSchema
  formContext: FormContext<P>
}

export const createField = <P extends object>({
  id,
  key,
  parentId,
  jsonSchema,
  formContext,
}: CreateFieldProps<P>) => {
  const field = new Tree<any>({
    getChildren: getChildrenSchemasFromValue(
      key
        ? formContext.fieldMap.get(parentId!)!.value[key]
        : formContext.value.current
    ),
    setChildren: (field, children) => {
      field.children = children
      return field
    },
  }).map<JsonSchema, Field>((jsonSchema, ctx) => {
    const field = _createField({
      id: ctx.key === undefined ? id : Symbol(),
      key: ctx.key ?? key,
      parentId: _.head(ctx.parents)?.id ?? parentId,
      jsonSchema,
      formContext,
    })
    formContext.fieldMap.set(field.id, field as Field<P>)
    return field
  }, jsonSchema)

  formTree.forEach(
    {
      post: (field) => {
        const store = formContext.createStore(field)
        formContext.fieldMap.set(field.id, store)
        formContext.onCreateField(store)
      },
    },
    field as Field<P>
  )

  return formContext.fieldMap.get(field.id)!
}

const _createField = <P extends object>({
  id,
  key,
  parentId,
  jsonSchema,
  formContext,
}: CreateFieldProps<P>): Field => {
  const getSelf = () => formContext.fieldMap.get(id)!
  return {
    // Static properties

    get id() {
      return id
    },
    get schema() {
      return jsonSchema
    },

    // Traversal properties

    key,
    get path() {
      const self = getSelf()
      return self.key !== undefined ? [...self.parent!.path, self.key] : []
    },
    get parent() {
      return parentId ? formContext.fieldMap.get(parentId)! : undefined
    },
    get children() {
      const self = getSelf()
      const children = (self.__state__.childrenIds as FieldId[])?.map(
        (id) => formContext.fieldMap.get(id)!
      )
      if (self.schema.type === "array") {
        return children
      }
      if (self.schema.type === "object") {
        return Object.fromEntries(children.map((field) => [field.key, field]))
      }
    },
    set children(children: Collection<Field<P>> | undefined) {
      if (children) {
        getSelf().__state__.childrenIds = Object.values(children).map(
          (field) => {
            formContext.fieldMap.set(field.id, field)
            return field.id
          }
        )
      }
    },

    // Value properties

    get value() {
      return get(formContext.value, ["current", ...getSelf().path])
    },
    set value(value) {
      set(formContext.value, ["current", ...getSelf().path], value)
    },
    get initial() {
      return get(formContext.value, ["initial", ...getSelf().path])
    },
    set initial(value) {
      set(formContext.value, ["initial", ...getSelf().path], value)
    },
    clean() {
      const self = getSelf()
      self.initial = _.cloneDeep(self.value)
    },
    reset() {
      const self = getSelf()
      self.value = _.cloneDeep(self.initial)
    },
    get dirty() {
      const self = getSelf()
      if (self.children) {
        return _.some("dirty", Object.values(self.children))
      }
      return !_.isEqual(self.value ?? "", self.initial ?? "")
    },

    // Form element properties

    get disabled() {
      return getSelf().parent?.disabled || getSelf().__state__.disabled
    },
    set disabled(value) {
      getSelf().__state__.disabled = value
    },
    get hidden() {
      return getSelf().__state__.hidden
    },
    set hidden(value) {
      getSelf().__state__.hidden = value
    },
    get required() {
      const self = getSelf()
      if (self.willValidate && self.parent?.schema.type === "object") {
        return (self.parent.schema.required ?? []).includes(self.key as string)
      }
      return false
    },
    set required(value) {
      const self = getSelf()
      if (self.parent?.schema.type === "object") {
        self.parent.schema.required = (value ? _.union : _.difference)(
          self.parent.schema.required,
          [self.key as string]
        )
      }
    },

    // Constraint validation properties

    // https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#constraint-validation
    // Normally the constraint validation spec specifies that fields be are
    // checked one by one, however a JSON schema can define relationships
    // between fields, making the constraint validation spec unsuitable. The
    // root field needs to be validated as a whole instead.
    get willValidate() {
      const self = getSelf()
      return !self.__state__.hidden && !self.__state__.disabled
    },
    setCustomValidity(message: string) {
      getSelf().__state__.validationMessage = message
    },
    checkValidity() {
      const self = getSelf()
      if (self.willValidate) {
        // Browsers can determine if a field satisfies validation constraints
        // and return an appropriate value from this method. We can't do that
        // (validation is run externally to this library) so we have to make the
        // assumption that a validation message means the field is invalid.
        return !self.__state__.validationMessage
      }
      return true
    },
    get validationMessage() {
      const self = getSelf()
      return self.checkValidity() ? "" : self.__state__.validationMessage
    },

    // Utilities

    get canAddChild() {
      const self = getSelf()
      return (
        jsonSchema.type === "array" &&
        (jsonSchema.maxItems ?? -1) < self.value?.length &&
        !self.disabled
      )
    },
    addChild(index?: number) {
      const self = getSelf()
      if (jsonSchema.type === "array") {
        index ??= _.size(self.value)
        self.value.splice(index, 0, getSchemaValue(jsonSchema.items))
        const field = createField({
          id: Symbol(),
          key: index,
          parentId: id,
          jsonSchema: jsonSchema.items,
          formContext,
        })
        self.__state__.childrenIds.splice(index, 0, field.id)
        for (const field of (self.children as any).slice(index + 1)) {
          field.key = (field.key as number) + 1
        }
      }
    },
    get canRemoveChild() {
      const self = getSelf()
      return (
        jsonSchema.type === "array" &&
        (jsonSchema.minItems ?? Infinity) >= _.size(self.value) &&
        !self.disabled
      )
    },
    removeChild(index?: number) {
      const self = getSelf()
      if (jsonSchema.type === "array") {
        index ??= _.size(self.value)
        self.value.splice(index, 1)
        const [id] = self.__state__.childrenIds.splice(index, 1)
        const removed = formContext.fieldMap.get(id)!
        removed.dispose()
        for (const field of (self.children as any).slice(index)) {
          field.key = (field.key as number) - 1
        }
      }
    },
    dispose() {
      formTree.forEach(
        { post: (field) => field.__state__.dispose?.() },
        getSelf()
      )
    },

    // Internal

    __state__: {
      disabled: !!jsonSchema.readOnly,
      childrenIds: [],
    },
  }
}
