// import { getSchemaValue } from "@json-schema-forms/json-schema-utils"
// import {
//   Collection,
//   TraversalContext,
//   Tree,
// } from "@json-schema-forms/tree-utils"
// import _ from "lodash/fp.js"
//
// import { createField,Field } from "./createField.js"
//
// export const formTree = new Tree<{ children?: Collection<unknown> }>({
//   getChildren(field) {
//     return field.children as Collection<typeof field>
//   },
//   setChildren(field, children) {
//     field.children = children
//     return field
//   },
// })
//
// export const accumulate =
//   <T, R>(fn: (node: T, ctx: TraversalContext<T>) => R) =>
//   (acc: Record<string, R>, node: T, ctx: TraversalContext<T>) => {
//     const result = fn(node, ctx)
//     if (result) {
//       acc[ctx.path.join(".")] = result
//     }
//     return acc
//   }
//
// /**
//  * A simple check against the `schema.maxItems` json-schema keyword
//  *
//  * @see {@link "https://json-schema.org/draft/2020-12/json-schema-validation.html#name-maxitems"}
//  */
// export const canAddChild = <P extends object>(field?: Field<P>) => {
//   return (
//     field &&
//     field.schema.type === "array" &&
//     (field.schema.maxItems ?? -1) < field.value?.length &&
//     !field.disabled
//   )
// }
//
// /**
//  * Insert a new item at `index` to `items` and `value` arrays
//  *
//  * @remarks
//  *
//  * The new item will be cloned from `schema.items` and initialized just as a top-level form schema would (e.g. `field`s will be recursively added). An new, empty value will be generated by `getSchemaValue(schema.items)` and inserted into `value`.
//  *
//  * @param index - The index at which to insert the new item. Defaults to `value.length` if omitted.
//  */
// export const addChild = <P extends object>(field: Field<P>, index?: number) => {
//   if (field.schema.type === "array") {
//     index ??= _.size(field.value)
//     field.value.splice(index, 0, getSchemaValue(field.schema.items))
//     const created = createField({
//       id: Symbol(),
//       key: index,
//       parentId: field.id,
//       jsonSchema: field.schema.items,
//       context: field.context,
//     })
//     field.__state__.childrenIds.splice(index, 0, created.id)
//     for (const child of (field.children as any).slice(index + 1)) {
//       child.key = (child.key as number) + 1
//     }
//   }
// }
//
// /**
//  * A simple check against the `schema.minItems` json-schema keyword
//  *
//  * @see {@link "https://json-schema.org/draft/2020-12/json-schema-validation.html#name-minitems"}
//  */
// export const canRemoveChild = <P extends object>(field?: Field<P>) => {
//   return (
//     field &&
//     field.schema.type === "array" &&
//     (field.schema.minItems ?? Infinity) >= _.size(field.value) &&
//     !field.disabled
//   )
// }
//
// /**
//  * Remove an item at `index` from `items` and `value` arrays
//  *
//  * @param index - The index at which to remove the element. Defaults to `value.length` if omitted.
//  */
// export const removeChild = <P extends object>(
//   field: Field<P>,
//   index?: number,
// ) => {
//   if (field.schema.type === "array") {
//     index ??= _.size(field.value)
//     field.value.splice(index, 1)
//     const [id] = field.__state__.childrenIds.splice(index, 1)
//     const removed = field.context.fieldMap.get(id)!
//     removed.dispose()
//     for (const child of (field.children as any).slice(index)) {
//       child.key = (child.key as number) - 1
//     }
//   }
// }
